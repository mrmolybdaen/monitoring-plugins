#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://github.com/Linuxfabrik/monitoring-plugins/blob/main/CONTRIBUTING.rst

"""See the check's README for more details.
"""

import argparse
import re
import sys

import apt
import apt_pkg

import lib.base  # pylint: disable=C0413
import lib.disk  # pylint: disable=C0413
import lib.distro  # pylint: disable=C0413
import lib.dmidecode  # pylint: disable=C0413
import lib.human  # pylint: disable=C0413
import lib.net  # pylint: disable=C0413
import lib.shell  # pylint: disable=C0413
import lib.txt  # pylint: disable=C0413
import lib.version  # pylint: disable=C0413
from lib.globals import STATE_OK, STATE_UNKNOWN, STATE_WARN, STATE_CRIT  # pylint: disable=C0413

__author__ = "XIMA Media GmbH, Dresden/Germany"
__version__ = "20240405"

DESCRIPTION = 'This check provides basic information about updatable packages,\nmostly using python-apt'

DEFAULT_CRIT = 0
DEFAULT_CRITICALITY_TYPE = 'uncritical'
DEFAULT_CRITICALITY_TYPES = ['security', 'dist-upgrade', 'uncritical']
DEFAULT_UPDATE = True
DEFAULT_WARN = 1

INFO_STR_UPDATE = ' (update)'
INFO_STR_UPGRADE = ' (upgrade)'
INFO_STR_SECURITY = ' (security)'


def parse_args():
    """Parse command line arguments using argparse module.
    """

    parser = argparse.ArgumentParser(description=DESCRIPTION)
    # Define base arguments
    parser.add_argument(
        '--always-ok',
        action='store_true',
        default=False,
        help='Always returns OK',
    )
    parser.add_argument(
        '-c', '--critical',
        type=int,
        default=DEFAULT_CRIT,
        help='Threshold number of packages to return "critical". '
             '"0" and unset do not emit critical'
    )
    parser.add_argument(
        '-w', '--warning',
        type=int,
        default=DEFAULT_WARN,
        help='Threshold number of packages to return "warning". '
             '"0" and unset do not emit warning'
    )
    # Define refining arguments
    parser.add_argument(
        '--criticality',
        nargs='+',
        default=DEFAULT_CRITICALITY_TYPE,
        choices=DEFAULT_CRITICALITY_TYPES,
        help='Defines on which type of package updates the check returns critical. '
             '"uncritical never returns critical" '
             '"dist-upgrade returns CRITICAL on dist-upgrades" '
             '"security" returns CRITICAL if the updated version\'s '
             'source is the distributions security repo'
    )
    parser.add_argument(
        '--show-extended',
        action='store_true',
        help='Show human readable package priority, package source repository '
             'and current and pending version.'
    )
    parser.add_argument(
        '--update',
        action='store_true',
        help='If set, check runs "apt update" on every run. Needs sudo.'
    )
    parser.add_argument(
        '-V', '--version',
        action='version',
        version='{0}: v{1} by {2}'.format('%(prog)s', __version__, __author__)
    )

    return parser.parse_args()


def apt_cache_init(update = False):
    """
        Initialize apt.cache.Cache(), optionally do apt.cache.Cache().update if update is True.
    """

    cache = apt.cache.Cache()
    if update:
        try:
            cache.update()
            cache.open()
        except apt.cache.LockFailedException as error:
            lib.base.oao(msg=f'Try using sudo!: {error}', state=STATE_CRIT, always_ok=False)

    return cache


def pkg_cache_get_installed(pkg_cache):
    """Get all installed packages from apt_pkg.Cache().
    """

    pkg_list = pkg_cache.packages
    pkg_names = []
    for pkg in pkg_list:
        pkg_proxy = apt.package.Package(pkg_cache, pkg)
        if pkg_proxy.is_installed:
            pkg_names.append(pkg.name)

    del pkg_proxy

    return pkg_names, len(pkg_names)


def get_upgradable(pkg_names, apt_cache, pkg_cache):
    """Get, count and return upgradable packages."""

    upgradable_dict = {}
    for name in pkg_names:
        package = apt_cache[name]

        if package.is_upgradable:
            upgradable_dict[name] = {}

    upgradable_package = []
    for name in upgradable_dict:
        upgradable_package.append(pkg_cache[name])

    upgradable_current = []
    for pkg in upgradable_package:
        if pkg.has_versions:
            upgradable_current.append(pkg.current_ver)
            upgradable_dict[pkg.name]['current_ver'] = pkg.current_ver.ver_str
            for version in pkg.version_list:
                if apt_pkg.version_compare(pkg.current_ver.ver_str, version.ver_str) < 0:
                    upgradable_dict[pkg.name]['next_ver'] = version.ver_str
                    upgradable_dict[pkg.name]['priority'] = version.priority_str
                    upgradable_dict[pkg.name]['size'] = lib.human.bytes2human(version.size)
                    break

    return upgradable_dict, len(upgradable_dict)


def hold_back(apt_output, upgrade_dict):
    """This string evaluates a list output and returns all hold back packages."""

    held_back = []
    start_hold, end_hold = None, None

    for line in apt_output:
        if "hold back" in line or "kept back" in line:
            start_hold = apt_output.index(line) + 1
        if "will be upgraded" in line:
            end_hold = apt_output.index(line)
            break

    if start_hold is not None and end_hold is not None:
        for index in range(start_hold, end_hold):
            held_back.extend(re.split(r'[\s\v]+', apt_output[index]))

    for pkg in held_back:
        if not pkg:
            held_back.remove(pkg)

    for pkg in upgrade_dict.keys():
        if pkg in held_back:
            upgrade_dict[pkg]['dist-upgrade'] = True
        else:
            upgrade_dict[pkg]['dist-upgrade'] = False

    return len(held_back)


def get_site_archive_component(origin, package_dict):
    """Gets site, archive and component properties of an apt.package.Origin object"""

    package_dict['site'] = origin.site
    package_dict['archive'] = origin.archive
    package_dict['component'] = origin.component


def is_security_upgrade(upgradable_dict, apt_cache):
    """This function returns whether a package is a security upgrade or not
        by checking its origin.
    """

    count_security = 0
    for name in upgradable_dict.keys():
        package = apt_cache[name]
        for v in package.versions:
            if v.version == upgradable_dict[name]['next_ver']:
                upgradable_dict[name]['summary'] = v.summary
                for o in v.origins:
                    if 'security' in o.archive:
                        upgradable_dict[name]['security'] = True
                        get_site_archive_component(o, upgradable_dict[name])
                        count_security += 1
                    else:
                        upgradable_dict[name]['security'] = False
                        get_site_archive_component(v.origins[0], upgradable_dict[name])

    return count_security


def apt_get_upgrade_simulation(upgrade_dict):
    """This function simulates apt-get upgrade
        It returns a list of hold back packages and
        updates from security lists.

        This is a workaround because phasing is part of python-apt 2.7.7
        which won't be available until at least Ubuntu 24.10 or Debian 13.
    """

    success, result = lib.shell.shell_exec('apt-get upgrade -q --simulate')

    if success:
        result_lines = result[0].splitlines()
        count_upgrade = hold_back(result_lines, upgrade_dict)

        return count_upgrade

    return -1


def show_extended(upgradable_dict, filter_list):
    """Return a table with extended package information"""

    msg = ''
    table_values = []

    for pkg in upgradable_dict.keys():
        condition = False
        if len(filter_list) > 1:
            for filter_str in filter_list:
                condition += upgradable_dict[pkg][filter_str]
            condition = not condition
        else:
            condition = upgradable_dict[pkg][filter_list[0]]

        if condition:
            table_values.append({
                    'package': pkg,
                    'current_ver': upgradable_dict[pkg]['current_ver'],
                    'next_ver': upgradable_dict[pkg]['next_ver'],
                    'size': upgradable_dict[pkg]['size'],
                    'priority': upgradable_dict[pkg]['priority'],
                    'archive': upgradable_dict[pkg]['archive'],
                    'component': upgradable_dict[pkg]['component'],
                    'site': upgradable_dict[pkg]['site'],
                })

    columns = table_values[0].keys()
    headers = ['Package', 'Current Ver.', 'New Version', 'Size', 'Priority', 'Archive', 'Component', 'Site']

    if len(table_values) > 0:
        msg = '\n\n'
        msg += lib.base.get_table(data=table_values, cols=columns, header=headers)

    return msg


def show_list_special(upgradable_dict, key):
    """Create a string containing an enumeration of keys in upgradable_dict"""

    enum_string = f'\n\n{key.capitalize()}:\n'
    for pkg in upgradable_dict.keys():
        if upgradable_dict[pkg][key]:
            enum_string += '  - ' + pkg + '\n'

    return enum_string


def show_list_normal(upgradable_dict):
    """Create a string containing an enumeration of keys in upgradable_dict"""

    enum_string = f'\n\nNormal updates:\n'
    for pkg in upgradable_dict.keys():
        if not upgradable_dict[pkg]['dist-upgrade'] and not upgradable_dict[pkg]['security']:
            enum_string += '  - ' + pkg + '\n'

    return enum_string


def main():
    """The main function. Hier spielt die Musik.
    """
    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    # This is quite unintuitive. But both Cache classes do have different
    # properties and methods and may be used in different functions.
    # They deliver different information.
    # == Initialize apt.cache.Cache() ==
    try:
        apt_cache = apt_cache_init(args.update)
    except Exception:
        lib.base.cu(msg='There might be a problem with some package repositories.')
    # == Initialize the apt_pkg.Cache() ==
    apt_pkg.init()
    pkg_cache = apt_pkg.Cache(progress=None)

    # Gather package information
    pkg_names, count_installed = pkg_cache_get_installed(pkg_cache)
    upgradable_dict, count_upgradable = get_upgradable(pkg_names, apt_cache, pkg_cache)
    count_security = is_security_upgrade(upgradable_dict, apt_cache)
    count_dist_upgrade = apt_get_upgrade_simulation(upgradable_dict)
    if count_dist_upgrade == -1:
        lib.base.cu()

    data_performance = ''

    exit_status = STATE_OK
    if count_upgradable:
        data_shown = f'Found pending updates. {count_upgradable}/{count_installed}, '\
                     + f'dist: {count_dist_upgrade}, security: {count_security}'

        # Set return status
        if args.warning and count_upgradable >= args.warning:
            exit_status = STATE_WARN
        if args.critical and count_upgradable >= args.critical:
            exit_status = STATE_CRIT

        if count_security:
            if not args.show_extended:
                data_shown += show_list_special(upgradable_dict, 'security')
            else:
                data_shown += '\n\nSecurity\n:'
                data_shown += show_extended(upgradable_dict, filter_list=['security'])
            if 'security' in args.criticality:
                exit_status = STATE_CRIT

        if count_dist_upgrade:
            if not args.show_extended:
                data_shown += show_list_special(upgradable_dict, 'dist-upgrade')
            else:
                data_shown += '\n\nSecurity:\n'
                data_shown += show_extended(upgradable_dict, filter_list=['dist-upgrade'])
            # Set optional criticality states
            if 'dist-upgrade' in args.criticality:
                exit_status = STATE_CRIT

        if not args.show_extended:
            data_shown += show_list_normal(upgradable_dict)
        else:
            data_shown += '\n\nStandard updates:\n'
            data_shown += show_extended(upgradable_dict, filter_list=['dist-upgrade', 'security'])

    else:
        data_shown = f'No upgradable packages found. {count_upgradable}/{count_installed}'

    # Finish
    # Prepare output data
    data_performance += lib.base.get_perfdata('installed', count_installed, None, None, None, 0, None)
    data_performance += lib.base.get_perfdata('upgradable', count_upgradable, None, None, None, 0, None)
    data_performance += lib.base.get_perfdata('security', count_security, None, None, None, 0, None)
    data_performance += lib.base.get_perfdata('dist-upgrade', count_dist_upgrade, None, None, None, 0, None)
    # Exit
    lib.base.oao(msg=data_shown, state=exit_status, perfdata=data_performance, always_ok=args.always_ok)


if __name__ == '__main__':
    try:
        main()
    except Exception:
        lib.base.cu()
