#!/usr/bin/env python3
# -*- coding: utf-8; py-indent-offset: 4 -*-
#
# Author:  Linuxfabrik GmbH, Zurich, Switzerland
# Contact: info (at) linuxfabrik (dot) ch
#          https://www.linuxfabrik.ch/
# License: The Unlicense, see LICENSE file.

# https://github.com/Linuxfabrik/monitoring-plugins/blob/main/CONTRIBUTING.rst

"""See the check's README for more details.
"""

import argparse
import re
import sys

import apt
import apt_pkg

import lib.base  # pylint: disable=C0413
import lib.disk  # pylint: disable=C0413
import lib.distro  # pylint: disable=C0413
import lib.dmidecode  # pylint: disable=C0413
import lib.human  # pylint: disable=C0413
import lib.net  # pylint: disable=C0413
import lib.shell  # pylint: disable=C0413
import lib.txt  # pylint: disable=C0413
import lib.version  # pylint: disable=C0413
from lib.globals import STATE_OK, STATE_UNKNOWN, STATE_WARN, STATE_CRIT  # pylint: disable=C0413

__author__ = "XIMA Media GmbH, Dresden/Germany"
__version__ = "20240405"

DESCRIPTION = 'This check provides basic information about updatable packages mostly using python-apt'

DEFAULT_CRIT = 1
DEFAULT_FORCE_APT = False
DEFAULT_TIMEOUT = 10
DEFAULT_TYPE = 'security'
DEFAULT_TYPES = ['security', 'dist-upgrade']
DEFAULT_UPDATE = True
DEFAULT_WARN = 0

DEBIAN_LIKE_FALLBACK = ['debian', 'ubuntu', 'mint', 'pop']

INFO_STR_UPDATE = ' (update)'
INFO_STR_UPGRADE = ' (upgrade)'
INFO_STR_SECURITY = ' (security)'


def parse_args():
    """Parse command line arguments using argparse module.
    """

    parser = argparse.ArgumentParser(description=DESCRIPTION)
    # Define base arguments
    parser.add_argument('-c', '--critical', type=int, default=DEFAULT_CRIT, help='')
    parser.add_argument('-w', '--warning', type=int, default=DEFAULT_WARN, help='')
    parser.add_argument('-t', '--timeout', type=int, default=DEFAULT_TIMEOUT, help='')
    # Define refining arguments
    parser.add_argument('--critical-type', nargs='?', default=DEFAULT_TYPE, choices=DEFAULT_TYPES, help='')
    parser.add_argument('--update', action='store_true',
                        help='If set, check runs "apt update" on every run. Needs sudo.')
    parser.add_argument('--force-apt', action='store_true',
                        help='Skip OS check and force script to assume apt is present.')
    parser.add_argument('--show-source', action='store_true', help='Show source of package updates.')
    parser.add_argument('--show-version', action='store_true',
                        help='Show current and updated versions number.')
    parser.add_argument('--show-priority', action='store_true', help='Show package priority.')


    return parser.parse_args()


def hold_back(apt_output):
    """This string evaluates a list output and returns all hold back packages."""

    held_back = []

    for line in apt_output:
        if "hold back" in line or "kept back" in line:
            start_hold = apt_output.index(line) + 1
        if "will be upgraded" in line:
            end_hold = apt_output.index(line)
            break

    for index in range(start_hold, end_hold):
        held_back.extend(re.split(r'[\s\v]+', apt_output[index]))

    for pkg in held_back:
        if not pkg:
            held_back.remove(pkg)

    return held_back, len(held_back)


def is_security_upgrade(upgradable_dict, apt_cache):
    """This function returns whether a package is a security upgrade or not
        by checking its origin.
    """

    count_security = 0
    for name in upgradable_dict.keys():
        package = apt_cache[name]
        for v in package.versions:
            if v.version == upgradable_dict[name]['next_ver']:
                for o in v.origins:
                    if 'security' in o.archive:
                        upgradable_dict[name]['security'] = True
                        count_security += 1
                    else:
                        upgradable_dict[name]['security'] = False

    return count_security


def apt_get_upgrade_simulation(pkg_list=None):
    """This function simulates apt-get upgrade
        It returns a list of hold back packages and
        updates from security lists.

        This is a workaround because phasing is part of python-apt 2.7.7
        which won't be available until at least Ubuntu 24.10 or Debian 13.
    """

    success, result = lib.shell.shell_exec('apt-get upgrade -q --simulate')

    if success:
        result_lines = result[0].splitlines()
        upgrade, count_upgrade = hold_back(result_lines)

        return upgrade, count_upgrade

    return success, 0


def main():
    """The main function. Hier spielt die Musik.
    """

    if lib.base.WINDOWS:
        lib.base.oao(msg='Check does not work on Windows.', state=STATE_CRIT, always_ok=False)
    # check linux flavour
    try:
        with open('/etc/os-release', 'r') as release_file:
            release = release_file.readlines()

    except FileNotFoundError as error:
        lib.base.oao(msg='Unable to find /etc/os-release', state=STATE_CRIT, always_ok=False)

    release_dict = {}
    for line in release:
        line_proxy = line.split('=')
        release_dict[line_proxy[0]] = line_proxy[1]

    flavour = ''
    if 'ID_LIKE' in release_dict.keys():
        flavour = release_dict['ID_LIKE']
    elif 'NAME' in release_dict.keys():
        flavour = release_dict['NAME']

    flavour = flavour.strip('\n').strip('\\n')

    if not flavour:
        lib.base.oao(msg='Could not determine distribution or flavour', state=STATE_CRIT, always_ok=False)

    if not flavour.lower() not in DEBIAN_LIKE_FALLBACK:
        lib.base.oao(msg='Not a Debian like distro!', state=STATE_CRIT, always_ok=False)

    try:
        args = parse_args()
    except SystemExit:
        sys.exit(STATE_UNKNOWN)

    apt_pkg.init()
    pkg_cache = apt_pkg.Cache(progress=None)
    apt_cache = apt.cache.Cache()

    pkg_list = pkg_cache.packages
    pkg_names = []
    for pkg in pkg_list:
        pkg_proxy = apt.package.Package(pkg_cache, pkg)
        if pkg_proxy.is_installed:
            pkg_names.append(pkg.name)

    del pkg_proxy

    upgradable = {}
    for name in pkg_names:
        package = apt_cache[name]

        if package.is_upgradable:
            upgradable[name] = {}

    upgradable_package = []
    for name in upgradable:
        upgradable_package.append(pkg_cache[name])

    upgradable_current = []
    for pkg in upgradable_package:
        if pkg.has_versions:
            upgradable_current.append(pkg.current_ver)
            upgradable[pkg.name]['current_ver'] = pkg.current_ver.ver_str
            for version in pkg.version_list:
                if apt_pkg.version_compare(pkg.current_ver.ver_str, version.ver_str) < 0:
                    upgradable[pkg.name]['next_ver'] = version.ver_str
                    upgradable[pkg.name]['priority'] = version.priority_str
                    break

    count_installed = len(pkg_names)
    count_upgradable = len(upgradable)
    count_security = is_security_upgrade(upgradable, apt_cache)

    dist_upgrade, count_dist_upgrade = apt_get_upgrade_simulation(pkg_list)

    print(f'Upgradable packages: {count_upgradable}/{count_installed}, security {count_security}, held_back {count_dist_upgrade}')
    for key in upgradable:

        print_str = f'{key}'
        if args.show_version or args.show_priority:
            print_str += ': '
        if args.show_version:
            print_str += f'{upgradable[key]["current_ver"]} -> {upgradable[key]["next_ver"]}'
        if args.show_priority:
            if args.show_version:
                print_str += ', '
            print_str += f'priority {upgradable[key]["priority"]}'

        print(print_str)

    apt_get_upgrade_simulation()



if __name__ == '__main__':
    try:
        main()
    except Exception:
        lib.base.cu()
